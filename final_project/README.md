# Проект параллельной сортировки на CPU и GPU

Этот проект реализует и сравнивает алгоритмы параллельной сортировки на CPU (используя OpenMP) и GPU (используя CUDA). Он демонстрирует разницу в производительности между последовательным выполнением на CPU, параллельным выполнением на CPU и массово-параллельным выполнением на GPU для сортировки больших массивов чисел с плавающей точкой.

## Обзор проекта

Цель этого проекта - реализовать:

1. **Последовательная сортировка на CPU**: Использование стандартной библиотеки C++ (`std::sort`).
2. **Параллельная сортировка на CPU**: Реализация алгоритма сортировки слиянием (Merge Sort) с использованием задач OpenMP.
3. **Параллельная сортировка на GPU**: Реализация алгоритма битонической сортировки (Bitonic Sort) с использованием CUDA.

Проект запускает тесты на массивах размером от 2^16 до 2^24 элементов и выводит таблицу сравнения производительности, а также CSV-файл. Также включен скрипт Python для визуализации результатов.

## Требования

- GPU NVIDIA с поддержкой CUDA.
- Установленный CUDA Toolkit.
- Microsoft Visual Studio (с нагрузкой "Разработка классических приложений на C++").
- Python 3 с установленными библиотеками `pandas` и `matplotlib`.

## Тестовая система

Код был скомпилирован и запущен в следующей среде:

- **ОС**: Microsoft Windows
- **CPU**: AMD Ryzen 7 6800HS with Radeon Graphics
- **GPU**: NVIDIA GeForce RTX 3060 Laptop GPU
- **Компилятор**: MSVC (Visual Studio 2022)
- **Фреймворки**: CUDA (для GPU), OpenMP (для CPU)

## Как запустить

Проект включает скрипт автоматической сборки, который управляет компиляцией, выполнением и визуализацией.

1. Откройте терминал (Command Prompt или PowerShell) и перейдите в директорию `final_project`.
2. Запустите скрипт `build.bat`:

    ```cmd
    build.bat
    ```

Этот скрипт выполняет следующие действия:

1. Настраивает переменные окружения компилятора MSVC (vcvars64).
2. Компилирует код CUDA и C++ с помощью `nvcc`, включая поддержку OpenMP и флаги оптимизации.
3. Запускает скомпилированный исполняемый файл `final_project.exe`.
4. Запускает скрипт визуализации Python `plot_results.py`.

После выполнения вы увидите текстовую таблицу в консоли с временем выполнения и статусом проверки. Также будет сгенерирован и автоматически открыт график `benchmark_plot.png`.

## Описание файлов

### main.cu

Это основная программа-драйвер. Она выполняет:

- Инициализацию тестовых данных (случайные массивы).
- Цикл по различным размерам массивов (степени двойки).
- Вызов функций сортировки CPU и GPU.
- Измерение времени выполнения для каждого метода с использованием таймеров высокого разрешения.
- Проверку корректности отсортированных массивов по сравнению с эталоном.
- Вывод таблицы результатов в консоль и экспорт данных в `results.csv`.

### build.bat

Пакетный скрипт для упрощения процесса сборки и запуска. Он:

- Инициализирует среду 64-битного компилятора Visual Studio.
- Компилирует `main.cu` с помощью `nvcc`, включая поддержку OpenMP и флаги оптимизации.
- Запускает исполняемый файл и затем скрипт визуализации.

### cpu_sort.h

Содержит реализации сортировки на CPU:

- **sequentialSort**: Обертка вокруг `std::sort` для базового последовательного теста.
- **parallelSort**: Реализует рекурсивную сортировку слиянием. Использует задачи OpenMP (`#pragma omp task`) для распараллеливания рекурсивных вызовов и `std::inplace_merge` для объединения отсортированных подмассивов. Переключается на последовательную сортировку для малых базовых случаев, чтобы уменьшить накладные расходы.

### gpu_sort.cuh

Содержит реализацию сортировки на GPU:

- **gpuBitonicSort**: Хост-функция, которая управляет запуском ядер CUDA. Она реализует итеративные шаги алгоритма битонической сортировки.
- **bitonic_sort_step**: Ядро CUDA (код устройства), которое проверяет и меняет местами элементы параллельно в соответствии с логикой битонической сортировки.

### utils.h

Предоставляет вспомогательные утилиты, используемые во всем проекте:

- **CpuTimer**: Класс для точного измерения времени с использованием `std::chrono`.
- **fillArray**: Генерирует случайные числа с плавающей точкой для тестовых массивов.
- **isSorted**: Проверяет, строго ли отсортирован массив.
- **verifyResults**: Сравнивает массив с надежным отсортированным эталоном для проверки корректности.
- **printTableHeader** / **printTableRow**: Вспомогательные функции для форматирования вывода в консоль.

### plot_results.py

Скрипт Python для визуализации данных. Он:

- Читает файл `results.csv`, сгенерированный `main.cu`.
- Использует `matplotlib` для построения графика времени выполнения реализаций CPU Sequential, CPU Parallel и GPU Bitonic в зависимости от размера массива.
- Сохраняет график как `benchmark_plot.png`.

### results.csv

Файл значений, разделенных запятыми (CSV), генерируемый во время выполнения. Он содержит сырые данные времени (в миллисекундах) для каждого размера массива и алгоритма, используемые скриптом Python для построения графика.
