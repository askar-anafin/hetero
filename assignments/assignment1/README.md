# Контрольные вопросы к Assignment 1 (Основы C/C++ и OpenMP)

### 1. В чём отличие динамического массива от статического массива в языке C++?

**Статический массив** имеет фиксированный размер, который должен быть известен на этапе компиляции (например, `int arr[100];`). Память под него выделяется автоматически (обычно в стеке).
**Динамический массив** создается во время выполнения программы с помощью оператора `new`. Его размер может определяться переменной (например, `new int[size];`), и память под него выделяется в куче (heap).

### 2. Что такое указатель и зачем он используется при работе с динамической памятью?

**Указатель** — это переменная, которая хранит адрес ячейки памяти. При выделении динамической памяти оператор `new` возвращает адрес начала выделенного блока. Указатель необходим, чтобы сохранить этот адрес, получать доступ к элементам массива и впоследствии корректно освободить память.

### 3. Почему важно корректно освобождать память после использования динамических массивов?

Если не освободить память с помощью `delete[]`, происходит **утечка памяти (memory leak)**. Эта память остается помеченной как "занятая" до завершения работы программы, хотя программа её больше не использует. При длительной работе или частом выделении памяти это может привести к переполнению оперативной памяти (RAM).

### 4. В чём разница между последовательной и параллельной обработкой массива?

* **Последовательная обработка:** Операции выполняются строго одна за другой в одном потоке на одном ядре процессора.
* **Параллельная обработка:** Задача разбивается на части, которые выполняются одновременно (параллельно) несколькими потоками на разных ядрах процессора, что теоретически сокращает время выполнения.

### 5. Что делает директива `#pragma omp parallel for`?

Эта директива OpenMP указывает компилятору, что следующий за ней цикл `for` нужно выполнить параллельно. Библиотека OpenMP автоматически создает группу потоков и распределяет итерации цикла между ними.

### 6. Для чего используется механизм reduction в OpenMP?

Механизм **reduction** (редукция) используется для безопасного объединения результатов вычислений, выполняемых в разных потоках, в одну общую переменную (например, для подсчета суммы, поиска минимума или максимума).

### 7. Почему при параллельном вычислении суммы необходимо использовать reduction, а не обычную переменную?

Если все потоки будут пытаться одновременно обновлять одну общую переменную (например, `sum += arr[i]`), возникнет состояние гонки (**data race**). Потоки будут перезаписывать результаты друг друга, и итоговая сумма будет неверной. `reduction` создает локальную копию переменной для каждого потока, а в конце корректно суммирует их результаты.

### 8. Какие факторы могут привести к тому, что параллельная версия программы будет работать медленнее последовательной?

* **Накладные расходы (Overhead):** Создание потоков и управление ими требует времени. Если задача слишком мала, эти расходы превысят выигрыш от параллелизма.
* **Ограничение пропускной способности памяти (Memory Bound):** Если вычисления простые (например, поиск минимума), процессор обрабатывает данные быстрее, чем память успевает их подавать. Добавление ядер не ускоряет доступ к памяти.
* **Синхронизация:** Затраты на блокировки или объединение результатов (reduction).
* **False Sharing:** Если разные потоки работают с данными, лежащими в одной кэш-линии процессора.
