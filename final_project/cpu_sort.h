#ifndef CPU_SORT_H
#define CPU_SORT_H

#include <algorithm> // Подключение библиотеки для стандартных алгоритмов
#include <omp.h> // Подключение библиотеки OpenMP для параллельного программирования
#include <vector> // Подключение библиотеки векторов

// Функция-обертка для последовательной сортировки
void sequentialSort(float* arr, size_t size) {
    std::sort(arr, arr + size); // Вызов стандартной функции сортировки std::sort
}

// Вспомогательная функция слияния для параллельной сортировки слиянием
// Сливает два отсортированных подмассива arr[l..m] и arr[m+1..r]
void merge(float* arr, int l, int m, int r) {
    int n1 = m - l + 1; // Размер левого подмассива
    int n2 = r - m; // Размер правого подмассива

    std::vector<float> L(n1); // Создание временного вектора для левой части
    std::vector<float> R(n2); // Создание временного вектора для правой части

    for (int i = 0; i < n1; i++) // Копирование данных в левый временный массив
        L[i] = arr[l + i];
    for (int j = 0; j < n2; j++) // Копирование данных в правый временный массив
        R[j] = arr[m + 1 + j];

    int i = 0, j = 0, k = l; // Индексы для слияния
    while (i < n1 && j < n2) { // Пока есть элементы в обоих массивах
        if (L[i] <= R[j]) { // Если элемент слева меньше или равен
            arr[k] = L[i]; // Записываем его в исходный массив
            i++; // Сдвигаем индекс левого массива
        } else { // Иначе
            arr[k] = R[j]; // Записываем элемент справа
            j++; // Сдвигаем индекс правого массива
        }
        k++; // Сдвигаем индекс исходного массива
    }

    while (i < n1) { // Копируем оставшиеся элементы левого массива, если есть
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) { // Копируем оставшиеся элементы правого массива, если есть
        arr[k] = R[j];
        j++;
        k++;
    }
}

// Рекурсивная функция параллельной сортировки слиянием с использованием OpenMP
void parallelMergeSortRec(float* arr, int l, int r) {
    if (l < r) { // Если в подмассиве больше одного элемента
        // Порог переключения на последовательную сортировку для избежания накладных расходов
        if (r - l < 1000) { 
            std::sort(arr + l, arr + r + 1); // Используем std::sort для малых массивов
        } else {
            int m = l + (r - l) / 2; // Находим середину массива

            #pragma omp task shared(arr) firstprivate(l, m) // Создаем задачу OpenMP для левой половины
            parallelMergeSortRec(arr, l, m); // Рекурсивный вызов для левой части

            #pragma omp task shared(arr) firstprivate(m, r) // Создаем задачу OpenMP для правой половины
            parallelMergeSortRec(arr, m + 1, r); // Рекурсивный вызов для правой части

            #pragma omp taskwait // Ожидаем завершения обеих задач
            
            // Слияние выполняется последовательно в этой реализации
            // std::inplace_merge удобен и часто оптимизирован
           std::inplace_merge(arr + l, arr + m + 1, arr + r + 1); // Слияние двух отсортированных частей
        }
    }
}

// Обертка для запуска параллельной области
void parallelSort(float* arr, size_t size) {
    #pragma omp parallel // Начало параллельной области OpenMP
    {
        #pragma omp single // Код внутри выполняется одним потоком (мастером), который порождает задачи
        parallelMergeSortRec(arr, 0, size - 1); // Запуск рекурсивной параллельной сортировки
    }
}

#endif // CPU_SORT_H
